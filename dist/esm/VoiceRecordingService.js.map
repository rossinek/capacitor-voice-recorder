{"version":3,"file":"VoiceRecordingService.js","sourceRoot":"","sources":["../../src/VoiceRecordingService.ts"],"names":[],"mappings":"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","sourcesContent":["import getBlobDuration from 'get-blob-duration';\n\nimport type { Base64String, CurrentRecordingStatus, GenericResponse, RecordingData } from './definitions';\n\nexport class VoiceRecordingService {\n  private stream: MediaStream | undefined;\n  private mediaRecorder: MediaRecorder | undefined;\n  private audioChunks: Blob[] = [];\n  private silenceDetectorNode: AudioWorkletNode | undefined;\n  private audioContext: AudioContext | undefined;\n\n  public async startRecording(options: {\n    onSilenceCallback?: () => void;\n    silenceThreshold?: number;\n  }): Promise<GenericResponse> {\n    console.log('>>>>> startRecording shark');\n    this.reset();\n    // eslint-disable-next-line no-async-promise-executor\n    return new Promise<GenericResponse>(async (resolve) => {\n      this.audioChunks = [];\n      this.stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n\n      this.mediaRecorder = new MediaRecorder(this.stream);\n\n      await this.setupSilenceDetector(options.onSilenceCallback ?? (() => console.log('onSilenceCallback not set')), options.silenceThreshold ?? 2.0);\n\n      this.mediaRecorder.ondataavailable = (event: BlobEvent) => {\n        this.audioChunks.push(event.data);\n      };\n      this.mediaRecorder.onstart = () => {\n        resolve({ value: true });\n      };\n      this.mediaRecorder.start(1000);\n    });\n  }\n\n  public stopRecording(): Promise<RecordingData> {\n    return new Promise((resolve) => {\n      if (!this.mediaRecorder) {\n        throw new Error(\"MediaRecorder is not initialized\");\n      }\n\n      this.mediaRecorder.onstop = () => {\n        setTimeout(async () => {\n          const audioBlob = new Blob(this.audioChunks, {\n            type: \"audio/wav; codecs=opus\"\n          });\n          const recordDataBase64 = await VoiceRecordingService.blobToBase64(audioBlob);\n          const mimeType = \"audio/wav; codecs=opus\";\n          const recordingDuration = await getBlobDuration(audioBlob);\n          resolve({ value: { recordDataBase64, mimeType, msDuration: recordingDuration * 1000 } });\n          this.reset();\n        }, 500);\n      };\n      this.stopMediaRecorder();\n    });\n  }\n\n  reset(): void {\n    this.audioChunks = [];\n    this.stopMediaRecorder();\n    this.cleanupSilenceDetector();\n  }\n\n  private static blobToBase64(blob: Blob): Promise<Base64String> {\n    return new Promise((resolve) => {\n      const reader = new FileReader();\n      reader.onloadend = () => {\n        const recordingResult = String(reader.result);\n        const splitResult = recordingResult.split('base64,');\n        const toResolve = splitResult.length > 1 ? splitResult[1] : recordingResult;\n        resolve(toResolve.trim());\n      };\n      reader.readAsDataURL(blob);\n    });\n  }\n\n  private stopMediaRecorder(): void {\n    this.mediaRecorder?.stop();\n    if (this.mediaRecorder) {\n      this.mediaRecorder.stream.getTracks().forEach(track => {\n        track.stop();\n      });\n    }\n    this.mediaRecorder = undefined;\n  }\n\n  private async setupSilenceDetector(onSilenceCallback: () => void, silenceThreshold: number): Promise<void> {\n    this.audioContext = new AudioContext();\n    await this.audioContext.audioWorklet.addModule(new URL('./audio-worklets/silence-detector-processor.js', import.meta.url));\n\n    if (!this.stream) {\n      throw new Error(\"Stream is not initialized\");\n    }\n\n    const sourceNode = this.audioContext.createMediaStreamSource(this.stream);\n    this.silenceDetectorNode = new AudioWorkletNode(\n      this.audioContext,\n      \"silence-detector-processor\",\n      {\n        processorOptions: {\n          silenceSecondsThreshold: silenceThreshold\n        }\n      }\n    );\n\n    this.silenceDetectorNode.port.onmessage = event => {\n      if (event.data.stopRecording) {\n        if (this.mediaRecorder?.state === \"recording\") {\n          onSilenceCallback();\n        }\n      }\n    };\n\n    sourceNode\n      .connect(this.silenceDetectorNode)\n      .connect(this.audioContext.destination);\n  }\n\n  private cleanupSilenceDetector(): void {\n    if (this.audioContext && this.audioContext.state !== \"closed\") {\n      this.audioContext.close();\n    }\n    this.silenceDetectorNode = undefined;\n    this.audioContext = undefined;\n  }\n\n  public static async requestAudioRecordingPermission(): Promise<GenericResponse> {\n    return { value: true };\n  }\n\n  public pauseRecording(): Promise<GenericResponse> {\n    throw new Error(\"Not implemented\");\n  }\n\n  public resumeRecording(): Promise<GenericResponse> {\n    throw new Error(\"Not implemented\");\n  }\n\n  public getCurrentStatus(): Promise<CurrentRecordingStatus> {\n    throw new Error(\"Not implemented\");\n  }\n\n  public static getSupportedMimeType(): string | null {\n    throw new Error(\"Not implemented\");\n  }\n}\n"]}